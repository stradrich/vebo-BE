package com.example.inventory.model;

import jakarta.validation.constraints.*;
// import lombok.Data;
// import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Document(collection = "inventory")
// @Data // Lombok annotation for getters, setters, toString, equals, and hashCode
// @NoArgsConstructor // Lombok annotation for a no-args constructor
public class Part {

    @Id
    private String uuid; // Auto-generated by MongoDB. Hidden from users.

    @NotNull(message = "SKU is mandatory.")
    @Pattern(regexp = "^[a-zA-Z0-9]+$", message = "SKU must be alphanumeric with no spaces.")
    private String sku; // Mandatory, unique, and alphanumeric. Last 2 chars = supplier code.

    @NotNull(message = "Status is mandatory.")
    @Pattern(regexp = "^(Active|Obsolete|On-Hold)$", message = "Status must be 'Active', 'Obsolete', or 'On-Hold'.")
    private String status; // Enum-like behavior for status options.

    @Pattern(regexp = "^https?://.*$", message = "Photo must be a valid URL.")
    private String photo; // Optional, URL format.

    private boolean controlled; // True if the part requires special handling.

    @NotNull(message = "Description is mandatory.")
    @Size(max = 40, message = "Description cannot exceed 40 characters.")
    private String description; // Mandatory, max 40 characters.

    @NotNull(message = "Type is mandatory.")
    @Pattern(regexp = "^(ORI|OEM|CHINA|USED|AFTERMKT|PACKAGE|OTHERS)$",
             message = "Type must be one of: ORI, OEM, CHINA, USED, AFTERMKT, PACKAGE, OTHERS.")
    private String type; // Mandatory, must match predefined types.

    @NotNull(message = "Supplier is mandatory.")
    @Pattern(regexp = "^(BA|KH|BY|CA|\\w+)$", message = "Supplier must be valid and match predefined codes.")
    private String supplier; // Mandatory, maintained list. Derived from SKU.

    @NotNull(message = "Cost price is mandatory.")
    @DecimalMin(value = "0.0", inclusive = false, message = "Cost price must be greater than 0.")
    private Double costPrice; // Mandatory. Currency format.

    @DecimalMin(value = "0.0", inclusive = false, message = "Selling price must be greater than 0.")
    private Double sellingPrice; // Auto-calculated as costPrice * 1.5. Non-editable.

    private boolean controlStock; // Enables stock-related fields.

    @Min(value = 0, message = "Stock level cannot be negative.")
    private Integer stockLevel; // Manually entered total stock.

    @Min(value = 0, message = "Reserved stock cannot be negative.")
    private Integer reservedStock; // Manually entered reserved stock.

    private Integer availableStock; // Auto-calculated: stockLevel - reservedStock.

    @Min(value = 0, message = "Minimum stock cannot be negative.")
    private Integer minimumStock; // Minimum stock before reorder.

    // Custom logic to calculate derived fields
    public void calculateDerivedFields() {
        // Auto-calculate sellingPrice as costPrice * 1.5
        this.sellingPrice = this.costPrice != null ? this.costPrice * 1.5 : 0.0;

        // Auto-calculate availableStock as stockLevel - reservedStock
        if (this.stockLevel != null && this.reservedStock != null) {
            this.availableStock = this.stockLevel - this.reservedStock;
        } else {
            this.availableStock = 0;
        }
    }
}